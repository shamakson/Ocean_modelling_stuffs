#! /bin/ksh

# Version for SLURM
#=============================================================================
#  Postprocessing of MPIOM on CSCS 
#=============================================================================
#SBATCH --job-name="PalOCEAN"
#SBATCH --time=03:00:00
##SBATCH --nodes=4
#SBATCH --ntasks=144
#SBATCH --ntasks-per-core=1
#SBATCH --ntasks-per-node=4
#SBATCH --account=s1032
#SBATCH --cpus-per-task=1
#SBATCH --partition=normal
#SBATCH --constraint=mc
#SBATCH --output=logs/PalOCEAN.%j.log
#SBATCH --error=logs/PalOCEAN.%j.log


######################################
#       PREPARE DIRECTORIES
#       AND RUN SCRIPT
######################################

# Supported queuing system
#   one of TWS (Tivoli Workload Scheduler - IBM), SGE (Sun Grid Engine),
#   NQS (Network Queuing System - NEC SX), or none
# @todo Currently also used for determining use of local files,
# @todo and for choice of parallel environment
queuing=SLURM
submit=sbatch
host=x86_64-unknown-linux-gnu
mpilaunch_args="${mpilaunch_args}"
HOSTNAME=$(hostname)
if [[ x"$job_time_limit" == x ]] ; then
  case "${queuing}" in
    SLURM)
      job_time_limit="04:00:00"
      ;;
  esac
fi

# computing platform/site settings and compiler:
case $queuing in
  SLURM) class="${class:-normal}";;
esac
if [ -x `which basename 2>/dev/null | grep -v 'no .* in'` ]; then
  compiler=`basename "ifort"`
else
  compiler=`echo "ifort" | sed 's:^.*/::'`
fi
# are we running an MPI parallel job?
MPI=""
# name of the experiment and grid resolution and level:
EXPNO="${EXPNO-GR15L40}"
GRID="${GRID-GR15}"
LEV="${LEV:-L40}"


# Pick your own working directory, e.g. $WRKSHR or /scratch/local1/$LOGNAME
# Default setting uses a user subdirectory in the default project area.
if [[ -z "$WORK" ]]
then
    GROUP=${GROUP:-$(cat $HOME/.acct 2> /dev/null)}
    GROUP=${GROUP:-$(id -Gn | tr ' ' '\n' | egrep '^[a-z]{2}[0-9]{4}$' | head -1)}
    GROUP=${GROUP:-$(id -gn)}
    [[ -d /scratch/snx3000 ]] && WORK=/scratch/snx3000
fi
WORKDIR="${WORKDIR:-$WORK/$LOGNAME}"

# Within WORKDIR, define standard location for projects.
SUBDIR="${SUBDIR:-experiments/mpiom-tests}"

# absolute path to work directory:
EXPDIR="${EXPDIR:-${WORKDIR}/${SUBDIR}/${EXPNO}}"

# absolute path to directory with plenty of space:
ARCDIR="${ARCDIR:-${WORKDIR}/${SUBDIR}/${EXPNO}}"

# absolute path to model binary:
MODDIR="${MODDIR:-/users/rhand/models/mpiom-1.6.3/bin}"

# model binary:
MODBIN="${MODBIN:-mpiom.x}"

# absolute path to directory with initial data:
INITIAL_DATA="${INITIAL_DATA:-/project/s1032/MPIOM_pool/input/r0013}"
# absolute path to directory with forcing data:
FORCING_DATA="${FORCING_DATA:-/project/s1032/MPIOM_pool/input/r0013}"

SINFO="${SINFO:-yes}"
SINFO_DIR="${SINFO_DIR:-${HOME}/experiment_info}"
SHORT_INFO="${SHORT_INFO:-'not_avaible'}"


nproca=${nproca:-2}    # tasks in x direction
nprocb=${nprocb:-2}    # tasks in y direction
nthread=1    # openmp threads
node_usage="${node_usage:-not_shared}"

ncpu=$(( nproca * nprocb * nthread ))

#
# hamocc
#
hamocc=false
enable_isotopes="${enable_isotopes:-no}"
enable_cyano="${enable_cyano:-no}"
enable_martin="${enable_martin:-no}"
enable_ndepo="${enable_ndepo:-no}"
use_transient_ndepo="${use_transient_ndepo:-no}"
ndep_start="${ndep_start:-1850}"

read_ghgfile=no

#passive tracers
enable_cfc=no
enable_age=no
enable_decay=no
enable_cs137=no

# profiling
profile=${profile:-}

#
# time control
#
ndays=${ndays:-0}         # number of days per run
nmonts=${nmonts:-12}      # number of months per run
nyears=${nyears:-0}       # number of years per run

######################################
#       PREPARE FORCING DATA
#       
######################################
# forcing data (NCEP, ERA, ERAINT, OMIP, NOAA)
#
OMIP_DATA=${FORCING_DATA}/SOURCE/forcing365/original_data    # use OMIP/runoff data

forcing=${forcing:-OMIP}                   # forcing data set

ldebug_forcing=false             # debug mode
lperiodic_forcing=false          # rewind forcing files to initial point at turn of year
lwrite_forcing=false             # write interpolated forcing fields for checking

case ${forcing} in
      OMIP)
          cforcdata='OMIP'                   # forcing data set
          forcing_frequency=86400          # distance between 2 nearest forcing times (seconds)
          model_start=${model_start:-1595-01-01} # initial date of simulation (YYYY-MM-DD)
          model_end=${model_end:-1610-01-01} # final date of simulation (YYYY-MM-DD)
          nfixYearLen=365           # length of the year (-1, 360, 365)
          forcing_start=1600-01-01         # forcing start year (YYYY-MM-DD)
          forcing_periodicity=-999         # number of available years in forcing data set
          lspat_interp_forcing=true  # spatial interpolation onto MPIOM grid
          ltime_interp_forcing=false       # linear time interpolation to the current model time
          ldiff_runoff_grid=false
	  lperiodic_forcing=true          # rewind forcing files to initial point at turn of year
	  lwrite_forcing=false             # write interpolated forcing fields for checking
          ;;
      NCEP24)
          cforcdata='NCEP'                   # forcing data set
          NCEP_DATA=${FORCING_DATA}/SOURCE/ncep_daily
          forcing_frequency=86400          # distance between 2 nearest forcing times (seconds)
          model_start=${model_start:-1948-01-01} # initial date of simulation (YYYY-MM-DD)
          model_end=${model_end:-2010-12-31} # final date of simulation (YYYY-MM-DD)
          nfixYearLen=-1                  # length of the year (-1, 360, 365)
          forcing_start=1948-01-01        # forcing start year (YYYY-MM-DD)
          forcing_periodicity=-1          # number of available years in forcing data set
          lspat_interp_forcing=true       # spatial interpolation onto MPIOM grid
          ltime_interp_forcing=true       # linear time interpolation to the current model time
          ldiff_runoff_grid=true          # use OMIP runoff data with NCEP forcing
          ;;
      NCEP6)
          cforcdata='NCEP'                   # forcing data set
          NCEP_DATA=${FORCING_DATA}/SOURCE/ncep
          forcing_frequency=21600          # distance between 2 nearest forcing times (seconds)
          model_start=${model_start:-1948-01-01} # initial date of simulation (YYYY-MM-DD)
          model_end=${model_end:-2015-12-31} # final date of simulation (YYYY-MM-DD)
          nfixYearLen=-1                  # length of the year (-1, 360, 365)
          forcing_start=1948-01-01        # forcing start year (YYYY-MM-DD)
          forcing_periodicity=-1          # number of available years in forcing data set
          lspat_interp_forcing=true       # spatial interpolation onto MPIOM grid
          ltime_interp_forcing=true       # linear time interpolation to the current model time
          ldiff_runoff_grid=true          # use OMIP runoff data with NCEP forcing
          ;;
      NOAA)
          cforcdata='NCEP'                   # forcing data set
          NOAA_DATA=${FORCING_DATA}/SOURCE/noaa
          forcing_frequency=21600          # distance between 2 nearest forcing times (seconds)
          model_start=${model_start:-1872-01-01} # initial date of simulation (YYYY-MM-DD)
          model_end=${model_end:-2007-12-31} # final date of simulation (YYYY-MM-DD)
          nfixYearLen=-1                  # length of the year (-1, 360, 365)
          forcing_start=1872-01-01        # forcing start year (YYYY-MM-DD)
          forcing_periodicity=-1         # number of available years in forcing data set
          lspat_interp_forcing=true       # spatial interpolation onto MPIOM grid
          ltime_interp_forcing=true       # linear time interpolation to the current model time
          ldiff_runoff_grid=true          # use OMIP runoff data with NOAA forcing
          ;;
      ERA)
          cforcdata='ERA'                   # forcing data set
          ERA_DATA=${FORCING_DATA}/SOURCE/era40
          forcing_frequency=21600          # distance between 2 nearest forcing times (seconds)
          model_start=${model_start:-1958-01-01} # initial date of simulation (YYYY-MM-DD)
          model_end=${model_end:-2000-12-31} # final date of simulation (YYYY-MM-DD)
          nfixYearLen=-1                  # length of the year (-1, 360, 365)
          forcing_start=1958-01-01        # forcing start year (YYYY-MM-DD)
          forcing_periodicity=-1         # number of available years in forcing data set
          lspat_interp_forcing=true       # spatial interpolation onto MPIOM grid
          ltime_interp_forcing=true       # linear time interpolation to the current model time
          ldiff_runoff_grid=true          # use OMIP runoff data with ERA forcing
          ;;
      ERAINT)
          cforcdata='ERAINT'                   # forcing data set
          ERAINT_DATA=${FORCING_DATA}/SOURCE/eraint
          forcing_frequency=21600          # distance between 2 nearest forcing times (seconds)
          model_start=${model_start:-1980-01-01} # initial date of simulation (YYYY-MM-DD)
          model_end=${model_end:-2012-12-31} # final date of simulation (YYYY-MM-DD)
          nfixYearLen=-1                  # length of the year (-1, 360, 365)
          forcing_start=1980-01-01        # forcing start year (YYYY-MM-DD)
          forcing_periodicity=-1         # number of available years in forcing data set
          lspat_interp_forcing=true       # spatial interpolation onto MPIOM grid
          ltime_interp_forcing=true       # linear time interpolation to the current model time
          ldiff_runoff_grid=true          # use OMIP runoff data with ERA forcing
          ;;
      ERA20C)
          cforcdata='ERA'                 # forcing data set
          ERA_DATA=${FORCING_DATA}/SOURCE/era20c
          forcing_frequency=10800          # distance between 2 nearest forcing times (seconds)
          model_start=${model_start:-1901-01-01} # initial date of simulation (YYYY-MM-DD)
          model_end=${model_end:-2010-12-31} # final date of simulation (YYYY-MM-DD)
          nfixYearLen=-1                  # length of the year (-1, 360, 365)
          forcing_start=1901-01-01        # forcing start year (YYYY-MM-DD)
          forcing_periodicity=-1          # number of available years in forcing data set
          lspat_interp_forcing=true       # spatial interpolation onto MPIOM grid
          ltime_interp_forcing=true       # linear time interpolation to the current model time
          ldiff_runoff_grid=true          # use OMIP runoff data with ERA forcing
          ;;
  esac


# Generate code series for regions and sections
get_codes() {
    typeset NO=$1 # number of code series
    typeset START=$2 # number of first code in first series
    typeset OFFSET=$3 # offset between series
    typeset SIZE=$4 # length of a single series
    shift; shift; shift; shift
    FILTER='fgrep -v -e dummy'
    if [ "x$1" = 'x-x' ]; then
        shift
        for x; do
            FILTER="$FILTER -e $x"
        done
    fi
    for i in `seq $START $OFFSET $((START+OFFSET*(NO-1)))`; do
        seq $i $((i+SIZE-1))
    done | $FILTER
}

# Global integrals/means (code range 512-520)
TIMESER_GLOBAL=$(seq 512 520)
# Section diagnostics (code range 610-815)
TIMESER_SECTIONS=644,645,724,725,684,685,$( seq 590 599 ; seq 610 765 | grep -v '[0-1,3-9]$' ; seq 770 815 | grep -v '[3-9]$' ; seq 600 609 | grep -v '[3-5]$'),809
#section maps
SECTION_MAPS=$(seq 1590 1815| grep -v '[0-3,6-9]$')
# Region diagnostics (code range 820-963)
TIMESER_REGIONS=$(seq 820 963)
TIMESER_SIMIP=613,614,615,623,624,625,633,634,635,703,704,705,$(seq 1030 1035)


if [[ "$GRID" = GR3M ]] ; then
    # Section diagnostics (code range 610-815)
    TIMESER_SECTIONS=$(get_codes 12 610 10 4)
    # Region diagnostics (code range 820-963)
    TIMESER_REGIONS=$(get_codes 5 820 16 16)
fi

if [ ! -d "$EXPDIR" ]; then
    /usr/bin/mkdir -p "${EXPDIR}"
    cd "${EXPDIR}"
#   cp ${MODDIR}/${MODBIN} ${MODBIN}  &&  MODDIR=${EXPDIR}
fi
if [ ! -d "$ARCDIR" ]; then
    /usr/bin/mkdir -p "$ARCDIR/restart"
    /usr/bin/mkdir -p "$ARCDIR/outdata"
fi

if [ -x '/client/bin/ksh' ]; then
  # where an override for ksh is installed, use that
  shell='/client/bin/ksh'
else
  shell='/bin/ksh'
fi

case ${queuing} in
  (TWS)
  [[ ${ncpu} -gt 32 ]] || mode=ST
  if [[ "${mode}" = "SMT" ]]; then
    [[ ${ncpu} -ge 64 ]] && tasks_per_node=64 ||  tasks_per_node=${ncpu}
    affinity=cpu
    memory_mb=750
  else
    [[ ${ncpu} -ge 32 ]] && tasks_per_node=32 ||  tasks_per_node=${ncpu}
    affinity=core
    memory_mb=1500
  fi
  ;;
  (SLURM)
  case $HOSTNAME in
  (thunder*)
    [[ ${ncpu} -ge 16 ]] && tasks_per_node=16 ||  tasks_per_node=${ncpu}
    ;;

  (btc*|mlogin*|*)
    if [[ "${class}" = "compute2" ]]; then
	[[ ${ncpu} -ge 36 ]] && tasks_per_node=36 ||  tasks_per_node=${ncpu}
    else
	[[ ${ncpu} -ge 24 ]] && tasks_per_node=24 ||  tasks_per_node=${ncpu}
    fi
    ;;
  esac
  ;;
esac

if [ x$task_geometry = xyes ]; then
  case ${queuing} in

    (TWS)
    # tasks per node in x direction
    if [ $nproca -ge 8 ]; then tilex=8 ;
    else tilex=$nproca ; fi
    (( tiley =  tasks_per_node / tilex ))   # tasks per node in y direction
    if [ $tiley -gt $nprocb ]; then
      if [ $nprocb -ge 8 ]; then tiley=8 ;
      else tiley=$nprocb ; fi
      (( tilex =  tasks_per_node / tiley ))   # tasks per node in y direction
    fi
    export TASK_GEOMETRY=`/users/rhand/models/mpiom-1.6.3-co/contrib/aix/geometry.pl ${nproca}-${nprocb}-${tasks_per_node}-${tilex}-${tiley}`
    (( ncpu = nproca * nprocb ))
    (( node = ncpu / tasks_per_node )) || { node=1 ; tasks_per_node=${ncpu} ; }

    ;;
  esac
else
  case ${queuing} in
    (TWS|SLURM)
    ((node = (nproca * nprocb + tasks_per_node - 1) / tasks_per_node ))
    ;;
  esac
fi

CDIDEF="" # empty string if CDI is enabled
REVISION='$Revision: 4587 $'

jobname="${jobname:-${EXPNO}}"
jobfile="${jobfile:-${EXPDIR}/${jobname}.job}"
cat >"${jobfile}" <<EOF1
#! ${shell}
#-----------------------------------------------------------------------------
#  Generated by $0, $REVISION
#-----------------------------------------------------------------------------
$(case ${queuing} in

  (TWS)
printf "
# Version for LoadLeveler
#
# @ shell = ${shell}
# @ class = ${class}
# @ job_type = parallel
# @ node_usage= ${node_usage}
$(if [[ $ncpu -gt 1 ]]; then
  echo "# @ rset = rset_mcm_affinity"
fi)
$(if [[ "${task_geometry}" = "yes" ]]; then
  echo "# @ mcm_affinity_options = mcm_accumulate"
  echo "# @ task_geometry = $TASK_GEOMETRY"
else
  echo "# @ mcm_affinity_options = mcm_distribute,mcm_mem_req"
  echo "# @ node = ${node}"
  echo "# @ tasks_per_node = ${tasks_per_node}"
fi)
# @ resources = ConsumableMemory(${memory_mb}mb)
# @ task_affinity = ${affinity}(${nthread})
# @ network.MPI = sn_all,${node_usage},us
# @ wall_clock_limit = ${job_time_limit}
# @ job_name = ${jobname}
# @ output = \$(job_name).o\$(jobid)
# @ error = \$(job_name).o\$(jobid)
# @ notification = error
# @ queue"
     ;;

  (SGE)
printf "
# Version for Sun GridEngine
#
#$ -S ${shell}
#$ -N ${jobname}
#$ -o \$JOB_NAME.o\$JOB_ID
#$ -j y
#$ -cwd
#$ -pe orte ${ncpu}"
     ;;

  (SLURM)
    printf "
# Version for SLURM
#SBATCH --job-name=${jobname}
#SBATCH --time=${job_time_limit}
#SBATCH --output=${jobname}.o-\%j.out
#SBATCH --error=${jobname}.o-\%j.out
#SBATCH --nodes=${node}
#SBATCH --ntasks=${ncpu}"
    case $HOSTNAME in
      (thunder*)
        printf "
#SBATCH --partition=mpi-compute
#SBATCH --account=mpi"
       ;;
      (btc*|mlogin*)
        printf "
#SBATCH --exclusive
#SBATCH --partition=$class
#SBATCH --threads-per-core=2
#SBATCH --cpus-per-task=2
#SBATCH --account=$GROUP"
       ;;
      (daint*)
        printf "
#SBATCH --exclusive
#SBATCH --partition=$class
#SBATCH --threads-per-core=2
#SBATCH --cpus-per-task=2
#SBATCH --constraint=gpu
#SBATCH --account=$GROUP"
       ;;

    esac
    printf "
# required ----------------
# use the same module here as for compiling
#
source \"$MODULESHOME/init/ksh\"
module load cdo/1.9.8-gnu-6.0.5
module load echam/6.3.05p2"

[[ x"/opt/cray/pe/mpt/7.7.10/gni/mpich-intel/16.0" == x*bullx* ]] && printf '
module purge        
module load cdo intel  mxm/3.4.3082 fca/2.5.2431 bullxmpi_mlx/bullxmpi_mlx-1.2.9.2
'

    ;;



  (NQS)
printf  "
# Version for NQSII
#
#PBS -S ${shell}
#PBS -N ${jobname}             # job name
#PBS -l cpunum_prc=${ncpu}     # 8 cpus per node
#PBS -l cputim_job=${job_time_limit}
#PBS -l memsz_job=5gb          # 48 GB Memory per node
#PBS -j o                      # join err and out to out"
     ;;

esac)

#-----------------------------------------------------------------------------
#
#                  Job file to run MPIOM with ${forcing} forcing
#
#-----------------------------------------------------------------------------
#
# If a command has a non-zero exit status, execute ERR trap, if set, and exit
#
set -ex
#
#=============================================================================
$(case ${queuing} in
  (TWS)
printf '
export MEMORY_AFFINITY=MCM
export MP_SINGLE_THREAD=yes
export MP_HOSTFILE=/pf/m/m211054/hostfile
#export PREATTACH_PROCESSOR_CORE_LIST=AUTO_SELECT
'
  ;;

  (SGE)
printf '
export FORT_BUFFERD="Y"
'
  ;;

  (NQS)
printf '
export MPIPROGINF=ALL_DETAIL
#export F_PROGINF=DETAIL
export F_SETBUF=4096
'
  ;;

esac)

export OMP_NUM_THREADS=1
export MPIOM_THREADS=$nthread
export MPIEXPORT="MPIOM_THREADS"

#
# hamocc
#
hamocc=${hamocc}
read_ghgfile=${read_ghgfile}
enable_cyano=${enable_cyano}
enable_martin=${enable_martin}
enable_isotopes=${enable_isotopes}
# N deposition
enable_ndepo=${enable_ndepo}
use_transient_ndepo=${use_transient_ndepo}
# start year of transient N-deposition 
ndep_start=${ndep_start}

#passive tracers
enable_cfc=${enable_cfc}
enable_age=${enable_age}
enable_decay=${enable_decay}
enable_cs137=${enable_cs137}

#
# profiling
#
profile=${profile}

$(if [[ ${queuing} == "TWS" ]]; then
printf '
([[ ${profile} == *@(mpiprofile)* ]] || [[ ${profile} == *@(hpmprofile)* ]]) && \
  (. /usr/lpp/ppe.hpct/env_sh)
  #. /usr/local/ihpct_2.2/env_sh   # RZG

if [[ ${profile} == *@(mpiprofile)* ]]; then
  export OUTPUT_ALL_RANKS="yes"
  export MAX_TRACE_RANK=128
  export MAX_TRACE_EVENTS=100000
  export TRACEBACK_LEVEL=2
fi

if [[ ${profile} == *@(hpmprofile)* ]]; then
  # also see hpct_guide.pdf
  export HPM_EVENT_SET="92,127"     # use hardware counter multiplexing with HPM_SLICE_DURATION per group
  #export HPM_SLICE_DURATION=100     # time interval in ms for measuring one hpc-group
  export HPM_OUTPUT_NAME="hpc_profile"
  export HPM_PRINT_FORMULA="yes"
  export HPM_UNIQUE_FILE_NAME="yes"
  export HPM_AGGREGATE=average.so   # write prof. with per event set averaged values
  #export HPM_AGGREGATE=mirror.so    # write unchanged profiles from indiv. tasks
  #export HPM_AGGREGATE=single.so    # write profile from one task (via env var HPM_PRINT_TASK)
fi
'
fi)

#
# time control
#
nfixYearLen=${nfixYearLen}   # length of the year (-1, 360, 365)
ndays=${ndays}
nmonts=${nmonts}
nyears=${nyears}
model_start=${model_start}
model_end=${model_end}

#
# forcing time control
#
forcing_frequency=${forcing_frequency}
forcing_start=${forcing_start}
forcing_periodicity=${forcing_periodicity}

# forcing interpolation control
lspat_interp_forcing=${lspat_interp_forcing} 
ltime_interp_forcing=${ltime_interp_forcing} 

EXPNO=${EXPNO}
echo "Experiment: \${EXPNO}"
SINFO=$SINFO
SINFO_DIR=$SINFO_DIR
SHORT_INFO=$SHORT_INFO


nprocx=$nproca
nprocy=$nprocb

(( ncpus = nprocx * nprocy ))
#
echo "   CPUs: \${ncpus} (nprocx: \${nprocx}, nprocy: \${nprocy})"
mpilaunch_args="${mpilaunch_args}"
#-----------------------------------------------------------------------------
#
EXPDIR=${EXPDIR}

# absolute path to model binary
MODDIR=${MODDIR}
MODBIN=${MODBIN}

# absolute path to directory with plenty of space:
ARCDIR=${ARCDIR}

# absolute path to directory with initial data:
INITIAL_DATA=${INITIAL_DATA}

# horizontal and vertical resolution
GRID=${GRID}
LEV=${LEV}

#-----------------------------------------------------------------------------
caulapuv=0.005
cah00=1000.
dv0=0.2e-2
av0=0.2e-2
dback=1.05e-5
aback=5.e-5
cdvocon=0.1
cavocon=0.0
cwt=0.5e-3
cwa=0.75e-3
cstabeps=0.03
ibolk=500
ltidal=.false.
iter_sor=300
rtsorpar=-999.
iter_sor_hack=0
rtsorpar_hack=-999.
iocad=3
iocaduv=3
lwith_ice_dynamics=.true.
lisopyc=.true.
luse_buoyancy_forcing=.true.
luse_windstress_forcing=.true.
lcalc_arcgri=.true.
numriv=0
lwith_one_layer_shelfs=.false.

SALINITY_CLIMATOLOGY=\${GRID}\${LEV}_INISAL_PHC
TEMPERATURE_CLIMATOLOGY=\${GRID}\${LEV}_INITEM_PHC
#TEMPERATURE_CLIMATOLOGY=ts_phc3.0_annual_mpiom_\${GRID}_\${LEV}.nc
#SALINITY_CLIMATOLOGY=ts_phc3.0_annual_mpiom_\${GRID}_\${LEV}.nc


$(if [[ x${DT:+set} = xset ]] ; then
  echo 'DT="'"${DT}"'"'
fi)


set_nudge_sss=.false.
set_nudge_sst=.true.
set_nudge_sao_region1=.false.
set_nudge_tho_region1=.false.
set_nudge_sao_region2=.false.
set_nudge_tho_region2=.false.

if [ "\${GRID}" = "GR60" ] ; then
  ie=60
  je=50
  DT="\${DT:-10800}"
  tp=false

elif [ "\${GRID}" = "TOY" ] ; then
  ie=66
  je=36
  DT="\${DT:-10800}"
  tp=true

elif [ "\${GRID}" = "MED11" ] ; then
  ie=503    
  je=231
  DT="${DT:-900}"
  tp=false
  caulapuv=0.0042
  cah00=400.
  cwt=2.5e-5
  cstabeps=0.1
  set_nudge_sao_region1=.true.,3.7e-7,1,1,1,120,8,29
  set_nudge_tho_region1=.true.,3.7e-7,1,1,1,120,8,29
  set_nudge_sao_region2=.true.,3.7e-7,1,9,8,133,8,29
  set_nudge_tho_region2=.true.,3.7e-7,1,9,8,133,8,29
  numriv=93

elif [ "\${GRID}" = "K20" ] ; then
  STA=-1
  ie=100
  je=100
  DT=3600
  tp=false
  iocad=0
  iocaduv=0
  cah00=1000. 
  caulapuv=0.001
  ibolk=0
  lisopyc=.false.  
  dv0=0.0
  av0=0.0
  dback=0.0
  aback=0.0
  cdvocon=0.0
  cavocon=0.0
  cwt=0.0
  cwa=0.0

  set_nudge_sss=.false.
  set_nudge_sao_region1=.false.
  set_nudge_tho_region1=.false.
  lwith_ice_dynamics=.false.
  luse_buoyancy_forcing=.false.
  luse_windstress_forcing=.false.
  lcalc_arcgri=.true.



elif [ "\${GRID}" = "ZC01" ] ; then
  ie=101
  je=51
  DT="\${DT:-3600}"
  tp=false
  caulapuv=0.001
  set_nudge_sss=.false.
  set_nudge_sao_region1=.false.
  set_nudge_tho_region1=.false.
  lwith_ice_dynamics=.false.
  lisopyc=.false.
  luse_buoyancy_forcing=.false.
  luse_windstress_forcing=.false.
  lcalc_arcgri=.true.
    
elif [ "\${GRID}" = "GR30" ] ; then
  ie=122
  je=101
  DT="\${DT:-8640}"
  tp=false

elif [ "\${GRID}" = "GR3M" ] ; then
  ie=144
  je=87
  DT="\${DT:-8640}"
  tp=false

elif [ "\${GRID}" = "GR15" ] ; then
  caulapuv=0.006
  ibolk=250
  ie=256
  je=220
  DT="\${DT:-3600}"
  tp=false

elif [ "\${GRID}" = "GI6" ] ; then

  SALINITY_CLIMATOLOGY=ts_phc3.0_annual_mpiom_\${GRID}_\${LEV}.nc
  TEMPERATURE_CLIMATOLOGY=ts_phc3.0_annual_mpiom_\${GRID}_\${LEV}.nc

  caulapuv=0.0045
  ibolk=0
  cah00=800.
  ie=802
  je=436
  DT="\${DT:-900}"
  tp=false
  cwt=3.5e-4
  relsal=1.5e-7
  cdvocon=0.15
  lwith_one_layer_shelfs=.true.


elif [ "\${GRID}" = "TP10" ] ; then
  ie=362
  je=192
  [[ "\${ltidal}" = ".true." ]] && DT="\${DT:-3600}" || DT="\${DT:-5400}"
  tp=true

elif [ "\${GRID}" = "TP04" ] ; then
  ie=802
  je=404
  DT="\${DT:-3600}"
  tp=true
  caulapuv=0.00375
  iter_sor=300
  rtsorpar=1.916
  iter_sor_hack=10
  rtsorpar_hack=0.7

elif [ "\${GRID}" = "TP6M" ] ; then
  ie=3602
  je=2394
  DT="\${DT:-600}"
  tp=true
  caulapuv=0.00375
  ibolk=0
  iter_sor=1200
  rtsorpar=1.934
  iter_sor_hack=10
  rtsorpar_hack=0.7
  iocad=8
  iocaduv=8

fi


if [ "\${LEV}" = "L3" ] ; then
  ke=3

elif [ "\${LEV}" = "L10" ] ; then
  ke=10

elif [ "\${LEV}" = "L20" ] ; then
  ke=20

elif [ "\${LEV}" = "L29" ] ; then
  ke=29

elif [ "\${LEV}" = "L31" ] ; then
  ke=31

elif [ "\${LEV}" = "L40" ] ; then
  ke=40

elif [ "\${LEV}" = "L80" ] ; then
  ke=80
fi


#-----------------------------------------------------------------------------
#
cd \${EXPDIR}           #  output and rerun files are written into \$ARCDIR
#
pwd
#-----------------------------------------------------------------------------
#
# initialisation or rerun 
#
# if mpiom finds a restart file it tries to continue the run
if [[ -f rerun_\${EXPNO}_mpiom.nc ]]; then
  restart=yes
  # file model_date.asc is updated by MPIOM at the end of each run
  # it contains 'run_start' 'run_end' and 'next_run_start' in YYYY-MM-DD format
  if [[ -f model_date.asc ]]; then
    model_date=\$(<model_date.asc)
    run_start=\$(echo \${model_date} | awk '{print \$3}')  # start date of actual run
  else
    run_start=\${model_start}
  fi
  STA=3   # start from restart files
else
  restart=no
  run_start=\${model_start}
#  STA=1   # start from uniform ocean T=0.C and S=35.0
#  STA=2   # start from Levitus
  STA="\${STA:-2}"
#  set_nudge_sao_region1=.true.
#  set_nudge_tho_region1=.true.

fi

# specification of files
#
#-----------------------------------------------------------------------------
#

#CP='cp -p'
#CP='ln -sf'
CP="${CP:-cdo -b 64B copy}"
CP2EXT="cdo -f ext -b 64B copy"
$(case "${host}-${compiler}" in
  (*?86*-*-linux-*-nagfor|*?86*-*-linux-*-nagf95|*?86*-*-darwin*-gcc)
    #for NAG compiler we need little endian
    echo "CP='cdo -b 64L copy'"
    echo "CP2EXT='cdo -f ext -b 64L copy'"  
    ;;
esac)

if [ \${lcalc_arcgri} == ".false." ] ; then
\cp \${INITIAL_DATA}/\${GRID}/\${GRID}_arcgri.nc            arcgri.nc
fi
\cp  \${INITIAL_DATA}/\${GRID}/\${GRID}_topo                topo
\$CP  \${INITIAL_DATA}/\${GRID}/\${GRID}_anta               anta
\cp \${INITIAL_DATA}/\${GRID}/\${GRID}_BEK                  BEK
set +e
chmod u+rw BEK
set -e

if [ \${STA} == "2" ] ; then
  cdo -selcode,5 \${INITIAL_DATA}/\${GRID}/\${SALINITY_CLIMATOLOGY}  INISAL
  cdo -selcode,2 \${INITIAL_DATA}/\${GRID}/\${TEMPERATURE_CLIMATOLOGY}  INITEM
fi

if [[ \${set_nudge_sao_region1} == .true.* || \${set_nudge_sao_region2} == .true.* ]] ; then
  cdo -setcode,58 -selcode,5 \${INITIAL_DATA}/\${GRID}/\${SALINITY_CLIMATOLOGY}  RELSAL

fi

if [[ \${set_nudge_tho_region1} == .true.* || \${set_nudge_tho_region2} == .true.* ]] ; then
  cdo -setcode,59 -selcode,2 \${INITIAL_DATA}/\${GRID}/\${TEMPERATURE_CLIMATOLOGY}  RELTEM
fi

if [[ \${set_nudge_sss} == .true.* ]] ; then
  cdo -sellevidx,1 -setcode,62 -selcode,5 \${INITIAL_DATA}/\${GRID}/\${SALINITY_CLIMATOLOGY}  RELSSS
fi

if [[ \${set_nudge_sst} == .true.* ]] ; then
  cdo -sellevidx,1 -setcode,63 -selcode,2 \${INITIAL_DATA}/\${GRID}/\${TEMPERATURE_CLIMATOLOGY}  RELSST
fi

if [ "\${GRID}" = "MED11" ] ; then
\$CP  \${INITIAL_DATA}/RUNOFF/runoff_obs_med                         runoff_obs
\$CP  \${INITIAL_DATA}/RUNOFF/runoff_pos_med                         runoff_pos
fi

#-----------------------------------------------------------------------------
if [ \${hamocc} == "true" ] ; then
# monthly mean dust field for hamocc

  \rm -f inpdust_r2.nc
  mm=\${run_start%-??}
  mm=\${mm#????-}
  cdo -setcode,34 -selmon,\${mm}/12 \${INITIAL_DATA}/\${GRID}/\${GRID}_MAHOWALDDUST_2005.nc inpdust_r2.nc

if [ \${enable_ndepo} == "yes" ] ; then
  \rm -f inpnit.nc

    ryear=\${run_start%-??-??}
    syear=\${model_start%-??-??}
    year=\$( expr \${ndep_start} + \${ryear} - \${syear})

if [ \${use_transient_ndepo} == "yes" ] ; then
  
  cdo -selmon,\${mm}/12 -selyear,\${year} \${INITIAL_DATA}/\${GRID}/\${GRID}_ndepo_CMIP_NCAR_CCMI-1-0_gr_185001-201412.nc inpnit.nc
  if [ \${year} -ge '2015' ] ; then
 # data for 2015-2100 are not yet available
 # cdo -selmon,\${mm}/12 -selyear,\${year} \${INITIAL_DATA}/\${GRID}/\${GRID}_ndepo_CMIP_NCAR_CCMI-1-0_gr_201501-210012.nc inpnit.nc
  echo "Data for 2015-2100 are not yet available: exiting"
  exit 1 
  fi
else
  cdo -selmon,\${mm}/12  \${INITIAL_DATA}/\${GRID}/\${GRID}_ndepo_CMIP_NCAR_CCMI-1-0_gr_185001-185012-clim.nc inpnit.nc
fi
fi

if [ \${read_ghgfile} == "yes" ] ; then
  \cp  \${INITIAL_DATA}/GHG/ghg_lawdome_giss_esrl_noaa_2015.txt ghg.txt
  set +e
  chmod u+rw ghg.txt
  set -e
fi
fi

set +e
chmod u+rw arcgri.nc topo anta BEK GI* INITEM INISAL
set -e

#-----------------------------------------------------------------------------

for lll in 1 ; do


echo \${run_start}

(( ntime = 86400 / forcing_frequency ))

if [ \${enable_cfc} == "yes" ] ; then
    CFC=',42,45'
    typeset -Z4 cfc_year
    cfc_year=\$(echo \${run_start} | awk -F\- '{print   \$1}')
    if [ \${cfc_year} -le '1910' ] ; then
      CFC=''
      cfc_year=1910
   fi
   cdo selyear,\${cfc_year}  \${INITIAL_DATA}/CFC/CFC_Atm_Hist_2015.nc           CFC_Atm.nc
fi

if [ \${enable_age} == "yes" ] ; then
    AGE=',39'
fi

if [ \${enable_decay} == "yes" ] ; then
    DECAY=',40'
fi

lcaesium_source='.false.'
if [ \${enable_cs137} == "yes" ] ; then
    CS137=',41'
    lcaesium_source=.true.
    caesium_source_latlon=34.42,141.02       #Fukushima
fi

    OMIP_DATA=${OMIP_DATA}
    NCEP_DATA=${NCEP_DATA}
    NOAA_DATA=${NOAA_DATA}
    ERA_DATA=${ERA_DATA}
    ERAINT_DATA=${ERAINT_DATA}
    forcing=${forcing}

$(  case ${forcing} in

      (OMIP)
        printf '%s' '

        if [ "${lspat_interp_forcing}" = "true" ]; then
          $CP ${OMIP_DATA}/land_sea_mask.ECMWF.nc                OMIP_LSM
          $CP ${OMIP_DATA}/east_west_stress.nc                   OMIP_WIX
          $CP ${OMIP_DATA}/north_south_stress.nc                 OMIP_WIY
          $CP ${OMIP_DATA}/2m_temp_arctic_corr.nc                OMIP_TEM
          $CP ${OMIP_DATA}/total_precipitation.nc                OMIP_PREC
          $CP ${OMIP_DATA}/total_solar_radiation.nc              OMIP_SWRAD
          $CP ${OMIP_DATA}/2m_dewpoint_temp_arctic_corr.nc       OMIP_TDEW
          $CP ${OMIP_DATA}/scalar_wind.nc                        OMIP_WIND10
          $CP ${OMIP_DATA}/total_cloud_cover.nc                  OMIP_CLOUD
          $CP ${OMIP_DATA}/runoff.nc                             OMIP_RIV
        else
          $CP2EXT OMIP_CLOUD_OUT    GICLOUD
          $CP2EXT OMIP_PREC_OUT     GIPREC
          $CP2EXT OMIP_RIV_OUT      GIRIV
          $CP2EXT OMIP_SWRAD_OUT    GISWRAD
          $CP2EXT OMIP_TDEW_OUT     GITDEW
          $CP2EXT OMIP_TEM_OUT      GITEM
          $CP2EXT OMIP_WIND10_OUT   GIU10
          $CP2EXT OMIP_WIX_OUT      GIWIX
          $CP2EXT OMIP_WIY_OUT      GIWIY
        fi  
        '
      ;;

      (NCEP24|NCEP6|NOAA|ERA|ERAINT|ERA20C)

        printf '%s' '
        # use OMIP runoff data

        if [[ ! -s omip_366_era15_runoff.${ntime}.nc ]] then
          cdo seltimestep,365 ${OMIP_DATA}/runoff.nc runoff_1day.nc    # select last day
          cdo -O mergetime -settaxis,0000-01-01,00:00,1day ${OMIP_DATA}/runoff.nc \
          -setdate,0000-12-31 runoff_1day.nc \
          -setdate,0001-01-01 runoff_1day.nc omip_366_era15_runoff.nc  # append 2 days
          if [[ ${ntime} -gt 1 ]]; then  # time interpolation
            cdo intntime,${ntime} omip_366_era15_runoff.nc omip_366_era15_runoff.${ntime}.nc
          else # daily forcing
            cp -p omip_366_era15_runoff.nc omip_366_era15_runoff.${ntime}.nc
          fi
        fi

        typeset -Z4 year yearend
        year=${run_start%-??-??}
        forcing_start_year=${forcing_start%-??-??}
        (( yearend = year + nyears + nmonts/12 + ndays/365 + 1 ))

        while [[ ${year} -le ${yearend} ]]; do
        (( forcing_year = year + forcing_start_year - ${model_start%-??-??} ))
        if [[ ${forcing_periodicity} -gt 0 ]]; then
          (( forcing_year = forcing_start_year + (forcing_year-forcing_start_year)%forcing_periodicity ))
        fi
        '
      ;;

    esac


    case ${forcing} in

     (NCEP6|NCEP24)
        printf '%s' '
        $CP ${OMIP_DATA}/land_sea_mask.ECMWF.nc            NCEP_LSM_RUNOFF
        $CP ${NCEP_DATA}/land.sfc.gauss.nc                       NCEP_LSM
        $CP ${NCEP_DATA}/uflx.sfc.gauss.${forcing_year}.nc       NCEP_WIX_${forcing_year}
        $CP ${NCEP_DATA}/vflx.sfc.gauss.${forcing_year}.nc       NCEP_WIY_${forcing_year}
        $CP ${NCEP_DATA}/air.2m.gauss.${forcing_year}.nc         NCEP_TEM_${forcing_year}
        $CP ${NCEP_DATA}/prate.sfc.gauss.${forcing_year}.nc      NCEP_PREC_${forcing_year}
        cdo mulc,0.89 ${NCEP_DATA}/dswrf.sfc.gauss.${forcing_year}.nc      NCEP_SWRAD_${forcing_year}
        $CP ${NCEP_DATA}/tdew.sfc.gauss.${forcing_year}.nc       NCEP_TDEW_${forcing_year}
        $CP ${NCEP_DATA}/wnd.10m.gauss.${forcing_year}.nc        NCEP_WIND10_${forcing_year}
        $CP ${NCEP_DATA}/tcdc.eatm.gauss.${forcing_year}.nc      NCEP_CLOUD_${forcing_year}
        ln -sf omip_366_era15_runoff.${ntime}.nc                         NCEP_RIV_${forcing_year}   # use OMIP runoff data
        #$CP ${NCEP_DATA}/runof.sfc.gauss.${forcing_year}.nc      NCEP_RIV_${forcing_year}
        #$CP ${NCEP_DATA}/pres.sfc.gauss.${forcing_year}.nc       NCEP_PRESS_${forcing_year}
        #$CP ${NCEP_DATA}/dlwrf.sfc.gauss.${forcing_year}.nc      NCEP_LWRAD_${forcing_year}
        #$CP ${NCEP_DATA}/uwnd.10m.gauss.${forcing_year}.nc       NCEP_U10_${forcing_year}
        #$CP ${NCEP_DATA}/vwnd.10m.gauss.${forcing_year}.nc       NCEP_V10_${forcing_year}
        '
        ;;

     (NOAA)
        printf '%s' '
        $CP ${OMIP_DATA}/land_sea_mask.ECMWF.nc            NCEP_LSM_RUNOFF
        $CP ${NOAA_DATA}/sflxgrbfg_6h_LAND_sfc.nc                     NCEP_LSM
        $CP ${NOAA_DATA}/sflxgrbfg_6h_${forcing_year}_UFLX_sfc.nc  NCEP_WIX_${forcing_year}
        $CP ${NOAA_DATA}/sflxgrbfg_6h_${forcing_year}_VFLX_sfc.nc NCEP_WIY_${forcing_year}
        $CP ${NOAA_DATA}/sflxgrbfg_6h_${forcing_year}_TMP_2m.nc    NCEP_TEM_${forcing_year}
        $CP ${NOAA_DATA}/sflxgrbfg_6h_${forcing_year}_PRATE_sfc.nc NCEP_PREC_${forcing_year}
        cdo mulc,0.89 ${NOAA_DATA}/sflxgrbfg_6h_${forcing_year}_DSWRF_sfc.nc     NCEP_SWRAD_${forcing_year}
        $CP ${NOAA_DATA}/tdew.sfc.gauss.${forcing_year}.nc  NCEP_TDEW_${forcing_year}
        $CP ${NOAA_DATA}/wnd.10m.gauss.${forcing_year}.nc   NCEP_WIND10_${forcing_year}
        $CP ${NOAA_DATA}/sflxgrbfg_6h_${forcing_year}_TCDC_high-cldlay.nc  NCEP_CLOUD_${forcing_year}
        ln -sf omip_366_era15_runoff.${ntime}.nc                         NCEP_RIV_${forcing_year}   # use OMIP runoff data
        '
        ;;

     (ERA)
        printf '%s' '
        $CP ${OMIP_DATA}/land_sea_mask.ECMWF.nc            ERA_LSM_RUNOFF
        cdo -f nc2 -b 32 copy ${ERA_DATA}/ERA40-LSM.nc ERA_LSM
        # divide by accumulation period and prevent negative numbers
        cdo -f nc2 -b 32 -R -max -divc,21600 -selyear,${forcing_year} ${ERA_DATA}/E4_precip_6h_195709-200108.grb -mulc,0 ${ERA_DATA}/E4_precip_6h_195709-200108.grb  ERA_PREC_${forcing_year}
        cdo -f nc2 -b 32 -R -max -divc,21600 -selyear,${forcing_year} ${ERA_DATA}/E4_swdown_6h_195709-200108.grb -mulc,0 ${ERA_DATA}/E4_swdown_6h_195709-200108.grb  ERA_SWRAD_${forcing_year}
        # divide by accumulation period
        cdo -f nc2 -b 32 -R divc,21600 -selyear,${forcing_year} ${ERA_DATA}/E4_ustress_6h_195709-200108.grb  ERA_WIX_${forcing_year}
        cdo -f nc2 -b 32 -R divc,21600 -selyear,${forcing_year} ${ERA_DATA}/E4_vstress_6h_195709-200108.grb  ERA_WIY_${forcing_year}
        #prepare snapshots
        cdo -f nc2 -b 32 -R selyear,${forcing_year} ${ERA_DATA}/E4_t2m_6h_195709-200108.grb  ERA_TEM_${forcing_year}
        cdo -f nc2 -b 32 -R selyear,${forcing_year} ${ERA_DATA}/E4_tdew_6h_195709-200108.grb ERA_TDEW_${forcing_year}
        cdo -f nc2 -b 32 -R selyear,${forcing_year} ${ERA_DATA}/E4_tcc_6h_195709-200108.grb  ERA_CLOUD_${forcing_year}
        cdo -f nc2 -b 32 -R selyear,${forcing_year} ${ERA_DATA}/E4_u10_6h_195709-200108.grb  ERA_U10_${forcing_year}
        cdo -f nc2 -b 32 -R selyear,${forcing_year} ${ERA_DATA}/E4_v10_6h_195709-200108.grb  ERA_V10_${forcing_year}
        #calculate scalar wind speed
        cdo -f nc2 -b 32 -R sqrt -add -sqr ERA_U10_${forcing_year} -sqr ERA_V10_${forcing_year}  ERA_WIND10_${forcing_year}
        ln -sf omip_366_era15_runoff.${ntime}.nc                         ERA_RIV_${forcing_year}   # use OMIP runoff data
        '
        ;;
     (ERAINT)
        printf '%s' '
        $CP ${OMIP_DATA}/land_sea_mask.ECMWF.nc  ERAINT_LSM_RUNOFF
        cdo -f nc2 -b 32 copy ${ERAINT_DATA}/EI075-LSM.grb ERAINT_LSM

        #prepare snapshots
        ( cdo -f nc2 -b 32 -R selyear,${forcing_year} ${ERAINT_DATA}/EI075_t2m_6h_197901-201305.grb  ERAINT_TEM_${forcing_year} )&
        ( cdo -f nc2 -b 32 -R selyear,${forcing_year} ${ERAINT_DATA}/EI075_tdew_6h_197901-201305.grb ERAINT_TDEW_${forcing_year} )&
        ( cdo -f nc2 -b 32 -R selyear,${forcing_year} ${ERAINT_DATA}/EI075_tcc_6h_197901-201305.grb  ERAINT_CLOUD_${forcing_year} )&
        ( cdo -f nc2 -b 32 -R selyear,${forcing_year} ${ERAINT_DATA}/EI075_u10_6h_197901-201305.grb  ERAINT_U10_${forcing_year} )&
        ( cdo -f nc2 -b 32 -R selyear,${forcing_year} ${ERAINT_DATA}/EI075_v10_6h_197901-201305.grb  ERAINT_V10_${forcing_year} )&


        # here we prepare the fluxes of precip, swdown, ustress and vstress ; note that the 12h and 00h values were accumulated over 12 hours ; therefor we
        #  substract 12h - 6h (00h - 18h) forcast to get a new 12h (00h) value that was accumulated only between 6h and 12h (18h and 00h) 

        for var in precip swdown ustress vstress ; do

          # start a sub shell
          
          ( if [[ ! -f EI075_${var}_6h_197901-201305.nc ]]; then      
  
            cdo -f nc2 -b 32 splithour ${ERAINT_DATA}/EI075_${var}_ac6h_197901-201305.grb EI075_${var}_ac6h_197901-201305_
            mv EI075_${var}_ac6h_197901-201305_06.nc EI075_${var}_6h_197901-201305_06.nc 

            cdo -f nc2 -b 32 sub EI075_${var}_ac6h_197901-201305_12.nc EI075_${var}_6h_197901-201305_06.nc EI075_${var}_6h_197901-201305_12.nc
            mv EI075_${var}_ac6h_197901-201305_18.nc EI075_${var}_6h_197901-201305_18.nc 

            cdo -f nc2 -b 32 sub EI075_${var}_ac6h_197901-201305_00.nc EI075_${var}_6h_197901-201305_18.nc EI075_${var}_6h_197901-201305_00.nc

            cdo -f nc2 -b 32 mergetime EI075_${var}_6h_197901-201305_??.nc EI075_${var}_6h_197901-201305.nc

            rm -f EI075_${var}_ac6h_197901-201305_00.nc
            rm -f EI075_${var}_ac6h_197901-201305_12.nc
            rm -f EI075_${var}_6h_197901-201305_00.nc
            rm -f EI075_${var}_6h_197901-201305_06.nc
            rm -f EI075_${var}_6h_197901-201305_12.nc
            rm -f EI075_${var}_6h_197901-201305_18.nc

          fi )&

        done

        wait

        # divide by accumulation period and prevent negative numbers

        ( cdo -f nc2 -b 32 -R -max -divc,21600 -selyear,${forcing_year} EI075_precip_6h_197901-201305.nc -mulc,0 EI075_precip_6h_197901-201305.nc  ERAINT_PREC_${forcing_year} )&
        ( cdo -f nc2 -b 32 -R -max -divc,21600 -selyear,${forcing_year} EI075_swdown_6h_197901-201305.nc -mulc,0 EI075_swdown_6h_197901-201305.nc  ERAINT_SWRAD_${forcing_year} )&

        # divide by accumulation period
        ( cdo -f nc2 -b 32 -R divc,21600 -selyear,${forcing_year} EI075_ustress_6h_197901-201305.nc  ERAINT_WIX_${forcing_year} )&
        ( cdo -f nc2 -b 32 -R divc,21600 -selyear,${forcing_year} EI075_vstress_6h_197901-201305.nc  ERAINT_WIY_${forcing_year} )&

        #calculate scalar wind speed from U10 and V10
        ( cdo -f nc2 -b 32 -R sqrt -add -sqr ERAINT_U10_${forcing_year} -sqr ERAINT_V10_${forcing_year}  ERAINT_WIND10_${forcing_year} )&

        ln -sf omip_366_era15_runoff.${ntime}.nc                          ERAINT_RIV_${forcing_year}   # use OMIP runoff data

        wait

        '
        ;;
     (ERA20C)
        printf '%s' '
        $CP ${OMIP_DATA}/land_sea_mask.ECMWF.nc                 ERA_LSM_RUNOFF
        $CP ${ERA_DATA}/LSM_F80_refine_0.3_nn.nc                ERA_LSM
        $CP ${ERA_DATA}/E20C_ustress_${forcing_year}.nc         ERA_WIX_${forcing_year}
        $CP ${ERA_DATA}/E20C_vstress_${forcing_year}.nc         ERA_WIY_${forcing_year}
        $CP ${ERA_DATA}/E20C_t2m_${forcing_year}.nc             ERA_TEM_${forcing_year}
        $CP ${ERA_DATA}/E20C_preci_${forcing_year}.nc           ERA_PREC_${forcing_year}
        $CP ${ERA_DATA}/E20C_swdown_${forcing_year}.nc          ERA_SWRAD_${forcing_year}
        $CP ${ERA_DATA}/E20C_tdew_${forcing_year}.nc            ERA_TDEW_${forcing_year}
        $CP ${ERA_DATA}/E20C_wind10_${forcing_year}.nc          ERA_WIND10_${forcing_year}
        $CP ${ERA_DATA}/E20C_tcc_${forcing_year}.nc             ERA_CLOUD_${forcing_year}
        ln -sf omip_366_era15_runoff.${ntime}.nc                ERA_RIV_${forcing_year}   # use OMIP runoff data
        '
        ;;

     esac

     case ${forcing} in
        (NCEP24|NCEP6|NOAA|ERA|ERAINT|ERA20C)
        printf '%s' '
        (( year = year + 1 ))
        done
        '
        ;;
      esac
)
#
# istart=0 >NEWSTART USE ONLY FOR COMPLETELY NEW SETUP (new topography etc!!!)
# istart=1 start from horizonally uniform t,s profiles
# istart=2 start from levitus
# istart=3 start from existing restart files rerun_mpiom, rerun_hamocc (default)
#
# Advection schemes
# iocad=3 ADPO (default)
# iocad=4 obsolete, use iocad=3 and ibbl_transport=1
# iocad=5 ADFS
#
# BBL transport (slope convection)
# ibbl_transport=1  (default)
# nfixYearLen = -1, 365 or 360 ; default -1 for 365/366 (leap years)
#
# ltidal=.true.  enables eph.tidal sub model (default=false)
#
# nyears: number of years to be simulated (default=0)
# nmonths: number of months to be simulated (default=1)
#

model_start=\$(echo \${model_start} | sed -e "s/-/,/g" -e "s/^,/-/"),0,0,0
forcing_start=\$(echo \${forcing_start} | sed -e "s/-/,/g" -e "s/^,/-/"),0,0,0

cat > OCECTL  << EOF
&proctl
 ltimer = .true.
/
&ocedim
 ie_g = \${ie}
 je_g = \${je}
 ke = \${ke}
 lbounds_exch_tp =  .\${tp}.
/
&nprocs
 nprocx=\${nprocx}
 nprocy=\${nprocy}
/
 &ocectl
 dt      = \${DT}
 caulapts= 0.
 caulapuv= \${caulapuv}
 aus     = 0.
 cah00   = \${cah00}
 ibolk   = \${ibolk}
 dv0     = \${dv0}
 av0     = \${av0}
 cwt     = \${cwt}
 cwa     = \${cwa}
 cstabeps= \${cstabeps}
 dback   = \${dback}
 aback   = \${aback}
 cdvocon = \${cdvocon}
 cavocon = \${cavocon}
 nfixYearLen = \${nfixYearLen}
 ltidal  = \${ltidal}
 lswr_jerlov = .true.
 jerlov_atten = 0.06
 jerlov_bluefrac = 0.41
 lfb_bgc_oce = .false.
 nyears  = \${nyears}
 nmonts  = \${nmonts}
 ndays   = \${ndays}
 istart  = \${STA}
 set_nudge_sss = \${set_nudge_sss}, 3.3e-7
 set_nudge_sst = \${set_nudge_sst}, 3.3e-7
 set_nudge_sao_region1 = \${set_nudge_sao_region1}
 set_nudge_tho_region1 = \${set_nudge_tho_region1}
 set_nudge_sao_region2 = \${set_nudge_sao_region2}
 set_nudge_tho_region2 = \${set_nudge_tho_region2}
$(if test -z "${MPI}"  ; then
printf '
 lmpitype = .false.
 lnonblock = .true.'
fi)
 icontro = 0
 iocad = \${iocad}
 iocaduv = \${iocaduv}
 ibbl_transport = 1
 lundelayed_momentum_advection = .true.
 rleadclose=0.25,3.0,2.0
 h0=0.5
 iter_sor = \${iter_sor}
 rtsorpar = \${rtsorpar}
 iter_sor_hack = \${iter_sor_hack}
 rtsorpar_hack = \${rtsorpar_hack}
 model_start_time = \${model_start}
 time_verbosity = 1
 lzo_correct = .true.
 lsaoclose = .true.
 rice_cutoff_factor = 0.9
 lcaesium_source = \${lcaesium_source}
$(if [[ "x${enable_cs137}" = "xyes" ]] ; then                                                                                                           printf '
 caesium_source_latlon = \${caesium_source_latlon}'
fi)
 lakes = .false.
 lwith_ice_dynamics = \${lwith_ice_dynamics}
 lisopyc = \${lisopyc}
 luse_buoyancy_forcing = \${luse_buoyancy_forcing}
 luse_windstress_forcing = \${luse_windstress_forcing}
 lcalc_arcgri = \${lcalc_arcgri}
 luse_sp_diag = .true.
 fp_tracing_enabled = .false.
 testbed = 0
 luse_cmip6_varlist = .true.
 numriv = \${numriv}
 lwith_one_layer_shelfs= \${lwith_one_layer_shelfs}
/
EOF

if [ \${ke} -eq 3 ] ; then
cat >> OCECTL  << EOF2
 &ocedzw
 cdzw     = 12.,10.,5000.,
 /
EOF2
fi

if [ \${ke} -eq 10 ] ; then
cat >> OCECTL  << EOF2
&ocedzw
  cdzw = 40., 50., 90., 160., 270., 390., 550., 900., 1300., 2300.
 /
EOF2
fi

if [ \${ke} -eq 20 ] ; then
cat >> OCECTL  << EOF2
 &ocedzw
  cdzw = 20.,20., 20., 30.,40.,50.,70.,
         90.,120.,150.,180.,210.,250.,300.,
         400.,500.,600.,700.,900.,1400.,
 /
EOF2
fi


if [ \${ke} -eq 29 ] ; then
cat >> OCECTL  << EOF2
 &ocedzw
 cdzw = 12.,10.,10.,10.,11.,13.,16.,19.,23., 23., 28., 33., 40., 
        48., 58., 70., 84.,102.,122.,148.,178.,214.,258.,311.,
        375.,400.,450.,500.,500. 
 /
EOF2
fi


if [ \${ke} -eq 31 ] ; then
cat >> OCECTL  << EOF2
 &ocedzw
  cdzw = 10.,10.,10.,10.,10.,10.,10.,10.,10.,10.,                
         15.,15.,15.,15.,15.,15.,15.,15.,20.,20.,                   
         20.,20.,20.,20.,25.,25.,30.,30.,30.,30.,30.,
 /
EOF2
fi

if [ \${ke} -eq 40 ] ; then
cat >> OCECTL  << EOF2
 &ocedzw
 cdzw     = 12.,10.,10.,10.,10.,10.,13.,15.,20.,25.,
            30.,35.,40.,45.,50.,55.,60.,70.,80.,90.,
            100.,110.,120.,130.,140.,150.,170.,180.,190.,200.,
            220.,250.,270.,300.,350.,400.,450.,500.,500.,600.,
 /
EOF2
fi

if [ \${ke} -eq 80 ] ; then
cat >> OCECTL  <<EOF2
 &ocedzw
 cdzw     = 12.,10.,10.,10.,10.,10.,10.,11.,11.,12.,
            13.,13.,14.,14.,15.,16.,16.,17.,18.,19.,
            20.,21.,21.,22.,24.,25.,26.,27.,28.,29.,
            31.,32.,34.,35.,37.,39.,40.,42.,44.,46.,
            48.,50.,53.,55.,58.,60.,63.,66.,69.,72.,
            76.,79.,83.,87.,91.,95.,99.,104.,108.,113.,
            119.,124.,130.,136.,142.,149.,155.,163.,170.,178.,
            186.,195.,204.,213.,223.,233.,244.,255.,267.,279.,
 /
EOF2
fi


# I/O (ioctl) namelist syntax
#
# iolist(N) = TYPE, FILE, FORMAT, CODE[, CODE...]
# N: unique number from 1 to 100 (not necessarily in sequence)
# TYPE: 99: restart file, 90: snapshot at start, 98: snapshot at end,
#       91: start file (read-only),
#       1: daily mean, 2: monthly mean, 3: annual mean, 4: per timestep,
#       5: 12-hourly mean, 6: 6h mean, 7: 3h mean, 8: 2h mean, 9: 1h mean.
#       Adding 100 gives snapshot instead, eg 101: snapshot at end of day;
#       adding 200 leaves land unmasked, 400 uses double precision output,
#       eg monthly output formatted like a restart file is 702 (2+100+200+400);
#       adding 800 defines input instead of output, eg 802: read record from
#       file for every month, 890: read at start (same as 91);
#       adding 1600 triggers synchronized mode, i.e. write buffers are flushed
#       after every step, useful for debugging;
#       adding 3200 allows input files to start over at end of file,
#       needed for multi-year runs with climatology,
#       adding 6400 triggers time minimum instead of time mean,
#       adding 12800 triggers time maximum instead of time mean,
#       adding 25600 triggers time summation instead of time mean,
#       NB: for input files, offsets 100-400, 1600, and file format are ignored!
# FILE: file name enclosed by quotes ('...') or double quotes ("...")
# FORMAT: file format: 'nc' NetCDF 1, 'nc2' NetCDF 2/3, 'nc4' NetCDF 4,
#                      'grb' GRIB 1, 'grbsz'/'sz' Compressed GRIB
# CODE...: list of variable code numbers (max. 255 codes)

FRMT=nc2

cat >> OCECTL  <<EOF2
 &ioctl
    iolist(100) = 99, 'rerun_\${EXPNO}_mpiom.nc', '\${FRMT}', 1, 2, 3, 4, 5, 7, 9, 10,
                  13, 15, 35, 36, 82, 99, 110, 111, 141, 501, 502, 503, 504, 507,  \${CFC} \${AGE} \${DECAY} \${CS137}

    iolist(99) = 2, '\${EXPNO}_mpiom_data_2d_mm.nc','\${FRMT}', 1, 11, 12, 13, 14,
                 15, 16, 17, 19, 20, 27, 35, 36, 66, 67, 70, 78, 79, 104, 109, 123, 124, 125, 126, 127, 128,
                 134, 136, 138, 139, 140, 141, 149, 150, 151, 153, 165, 168, 169, 170, 181, 183, 215, 216,
                 217, 218, 219, 220, 221, 222, 223, 224, 226, 227, 228, 229, 275, 276, 277, 278, 280, 285, 286,
                 287, 288, 521, 522, 523, 524, 548, 549,
                 1013, 1015, 1016, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1036, 1037, 1038,
                 1039, 1040, 1041, 1042, 1043, 1044 ,1047, 1048

    iolist(69) = 6402,'\${EXPNO}_mpiom_data_2d_mmin.nc','\${FRMT}',276
    iolist(68) = 12802,'\${EXPNO}_mpiom_data_2d_mmax.nc','\${FRMT}',276
    iolist(67) = 12801,'\${EXPNO}_mpiom_data_2d_dmax.nc','\${FRMT}',276

    iolist(91) = 3, '\${EXPNO}_mpiom_data_2d_ym.nc','\${FRMT}', 277, 278

    iolist(90) = 1, '\${EXPNO}_mpiom_data_2d_dm.nc','\${FRMT}', 12, 13, 14, 15, 16, 104, 109, 140, 141, 1016, 1022, 1023, 1024, 1025, 1026, 1027, 1028

    iolist(98) = 2, '\${EXPNO}_mpiom_timeser_mm.nc','\${FRMT}', 508, 509, 515, 516, $(echo ${TIMESER_GLOBAL} ${TIMESER_SECTIONS} ${TIMESER_REGIONS} ${TIMESER_SIMIP} | sed 's/ /,/g;s/.{80}/&\n/g')

    iolist(97) = 2, '\${EXPNO}_mpiom_data_moc_mm.nc','\${FRMT}', 93, 94, 95, 96, 97, 98, 100, 101, 102, 106, 107, 108,
                 1093,1094,1095,1096,1097,1098,1099,1100,1101, 1112, 1113, 1114

    iolist(96) = 2, '\${EXPNO}_mpiom_monitoring_mm.nc','\${FRMT}', 508, 509, 515, 516, 519, 520, 622, 652,
                 672, 703, 800, 836, 837, 900, 901, 936, 950, 951, 952, 953,
                 955, 956, 958, 959, 961, 962, 1001

    iolist(95) = 2, '\${EXPNO}_mpiom_data_3d_mm.nc', '\${FRMT}', 2, 3, 4, 5, 6, 7, 18, 21, 22, 23, 24, 54, 110, 112, 135, 197, 203, 204, 207, 208, 214, 279 \${AGE} \${DECAY} \${CS137}

    iolist(94) = 3, '\${EXPNO}_mpiom_data_3d_ym.nc', '\${FRMT}', 25, 26, 28, 30, 88, 90, 111, 152, 282, 1029, 1030, 1031, 1032

!   iolist(92) = 98,'\${EXPNO}_mpiom_condep.nc','\${FRMT}',180
   iolist(79) = 2,'\${EXPNO}_mpiom_tendencies_mm.nc','\${FRMT}', 25, 26, 28, 30, 88, 90, 1029, 1030, 1031, 1032
!   iolist(78) = 2,'\${EXPNO}_mpiom_eddy_mm.nc','\${FRMT}',1,17,113,114,115,116,117,118,119,120,121,122,230,231,232,233,234,235,
!                236,237,238,239,240,241,242,243,244
!   iolist(77) = 1,'\${EXPNO}_mpiom_fluxes_dm.nc','\${FRMT}',52,53,215,216,217,218,219,220,221,222,223,224,225
!   iolist(76) = 1,'\${EXPNO}_mpiom_100m_dm.nc','\${FRMT}',245,246,247,248,253
!   iolist(75) = 1,'\${EXPNO}_mpiom_2000m_dm.nc','\${FRMT}',249,250,251,252,253,254

    iolist(81) = 90,'\${EXPNO}_mpiom_map.nc','\${FRMT}',511,$(echo ${SECTION_MAPS}  | sed 's/ /,/g;s/.{80}/&\n/g')
    iolist(80) = 90,'\${EXPNO}_mpiom_fx.nc','\${FRMT}',56,57,84,85,86,87,154,155,172,174,175,184,185,186,187,188,189,190,191,192,193,194,195,196

\$(
 if [ \${enable_cfc} == "yes" ]
 then
        echo "iolist(82)  = 803,'CFC_Atm.nc', 'nc4',43,44,46,47"
        echo "iolist(83)  = 2,'\${EXPNO}_mpiom_cfc_mm.nc','\${FRMT}' \${CFC}"
 fi
)
\$(
    if [ \${STA} == "2" ]
    then
        echo " iolist(84)  = 890,'INISAL', 'nc4',5"
        echo " iolist(85)  = 890,'INITEM', 'nc4',2"
    fi
)
\$(
  if [[ \${set_nudge_sao_region1} == .true.* || \${set_nudge_sao_region2} == .true.* ]] ; then
    echo " iolist(86)  = 890,'RELSAL', 'nc4',58"
  fi
)
\$(
  if [[ \${set_nudge_tho_region1} == .true.* || \${set_nudge_tho_region2} == .true.* ]] ; then
    echo " iolist(87)  = 890,'RELTEM', 'nc4',59"
  fi
)
\$(
  if [[ \${set_nudge_sss} == .true.* ]] ; then
    echo " iolist(88)  = 890,'RELSSS', 'nc4',62"
  fi
)
\$(
  if [[ \${set_nudge_sst} == .true.* ]] ; then
    echo " iolist(89)  = 890,'RELSST', 'nc4',63"
  fi
)

 /
EOF2

cat >> OCECTL <<EOF2
  &forcctl
  cforcdata='${cforcdata}'
  forcing_frequency = \${forcing_frequency}
  forcing_start_time = \${forcing_start}
  lwrite_forcing=.${lwrite_forcing}.
$(if [ -z "$CDIDEF" ]; then
  echo "  lspat_interp_forcing=.\${lspat_interp_forcing}."
  echo "  ltime_interp_forcing=.\${ltime_interp_forcing}."
fi)
  forcing_periodicity = \${forcing_periodicity}
  luse_model_time = .true.
  lperiodic_forcing=.${lperiodic_forcing}.
  ldebug_forcing=.${ldebug_forcing}.
  ldiff_runoff_grid=.${ldiff_runoff_grid}.
  /
EOF2

#
# hamocc
#
if [ \${hamocc} == "true" ] ; then

millennium_ctrl=false
if [ \${millennium_ctrl} = "false" ]; then
 deltacalc=0.0
 deltaorg=0.0
 deltasil=0.0
else
 deltacalc=493.57
 deltaorg=2.457
 deltasil=0.22
fi

if [ \${read_ghgfile} == "yes" ] ; then
 typeset -Z4 ghg_year
 ghg_year=\${run_start%-??-??}
 co2ppm=\$(awk "/^ *\${ghg_year}\\.00/ { print \\\$2 }" ghg.txt)
else
 co2ppm=278.0
fi

if [ \${enable_isotopes} == "yes" ] ; then
Riso=', 8, 9, 18, 19, 25, 26, 39, 40, 42, 43, 52, 53, 89, 90'
Oiso=', 8, 9, 18, 19, 25, 26, 89, 90'
Siso=', 39, 40, 42, 43, 52, 53, 87, 88, 288, 289'
Aiso=', 103, 104'
else
Riso=''
Oiso=''
Siso=''
Aiso=''
fi
if [ \${enable_cyano} == "yes" ] ; then
RCYA=', 145'
OCYA=', 145, 166'
MCYA=', 520'
EUCYA=', 297'
LCYA='.true.'
else
RCYA=''
MCYA=''
OCYA=''
EUCYA=''
LCYA='.false.'
fi
if [ \${enable_martin} == "yes" ] ; then
LMAR='.true.'
else
LMAR='.false.'
fi
if [ \${enable_ndepo} == "yes" ] ; then
LNDEP='.true.'
else
LNDEP='.false.'
fi

#creates daily averages for bgc timeseries
(( TSDT = 86400 / DT ))

# For ioctl namelist syntax, see MPIOM section above

cat > NAMELIST_BGC  << EOF2
 &BGCCTL
 deltacalc   =  \${deltacalc}
 deltaorg    =  \${deltaorg}
 deltasil    =  \${deltasil}
 io_stdo_bgc =  8,
 kchck       =  0,
 isac        =  1,
 rmasko      = -9e33
 atm_co2     = \${co2ppm}
 l_cyadyn    = \${LCYA}
 lmartin     = \${LMAR}
 lndep       = \${LNDEP}
 /
&ioctl
    !
    ! iolist elements from 100 - 80 are reserved for default output definitions
    !
    iolist(100) = 99, 'rerun_\${EXPNO}_hamocc.nc', '\${FRMT}', 7, 10, 11, 12, 13, 14,
                  15, 16, 17, 20, 21, 22, 23, 24, 27, 28, 29, 30, 31, 36, 37, 38,
                  41, 44, 45, 46, 47, 48, 49, 50, 51, 54, 55, 56, 57, 58, 59,
                  60, 61, 62, 63, 64, 203, 204, 205\${RCYA}\${Riso} 
    iolist(99) = 4002, 'inpdust_r2.nc', '\${FRMT}', 34
\$(
 if [ \${enable_ndepo} == "yes" ]
 then
        echo "    iolist(98)  = 4002,'inpnit.nc', '\${FRMT}',35"
 fi
)
    iolist(97) = 3, '\${EXPNO}_hamocc_data_3d_ym.nc', '\${FRMT}', 7, 10, 11, 12, 14,
                 15, 16, 17, 20, 21, 22, 23, 24, 27, 28, 29, 31, 36,37, 158\${OCYA}\${Oiso}
    iolist(96) = 2, '\${EXPNO}_hamocc_eu_data_mm.nc', '\${FRMT}', 69, 70, 71, 84, 85,
                 86, 100, 101, 292, 293, 294, 295, 296, 297, 143,187,188, 510\${EUCYA}

    iolist(95) = 2, '\${EXPNO}_hamocc_data_2d_mm.nc', '\${FRMT}', 67, 68, 72, 75, 78,
                 81, 92, 93, 94, 95, 107, 110, 111, 112, 114, 115, 116, 117,
                 120, 121, 122, 123, 124, 127, 129, 131, 137, 144, 157, 159, 160,
                 161, 162, 163, 164, 165, 174, 185, 186, 200, 206, 207, 210, 211,
                 214, 215, 231\${Aiso}
    iolist(94) = 101, '\${EXPNO}_hamocc_co2.nc', '\${FRMT}', 301, 303, 304, 305, 306,
                 307, 308, 309, 310, 311, 312, 313, 314, 203, 204, 205
    iolist(93) = 3, '\${EXPNO}_hamocc_monitoring_ym.nc', '\${FRMT}', 500, 501, 502,
                 503, 504, 505, 506, 507, 508, 509, 517, 519,  523\${MCYA}, 529, 530,
                 531, 532, 533, 534, 535
    iolist(92) = 3, '\${EXPNO}_hamocc_sedi_ym.nc', '\${FRMT}', 38, 41, 44, 45, 46, 47,
                 48, 49, 50, 51, 54, 55, 56, 57, 58, 59, 60, 94, 95, 96, 97, 63, 290,
                 167,168, 280, 281, 282, 283, 284, 285, 286, 287\${Siso}
!   iolist(91) = 2,'\${EXPNO}_hamocc_eddy_mm.nc','\${FRMT}',315,316,317,318,319,320,
!                 321,322,323,324,325,326,234,235,236,72
!    iolist(90)=2,'\${EXPNO}_hamocc_stations_mm.nc','\${FRMT}',
!                 1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,
!                 2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,
!                 3001,3002,3003,3004,3005,3006,3007,3008,3009,3010,3011
/

EOF2
#
fi

#=============================================================================
echo "Integration started on \$(date)"
$(case ${queuing} in
  (TWS)
printf '
# with binding
#unset MP_TASK_AFFINITY
#export TARGET_CPU_LIST=-1
#export TARGET_CPU_LIST="0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30"

#export TARGET_CPU_RANGE=-1
#poe ~puetz/bin/launch ${MODDIR}/${MODBIN} -procs $ncpus -hfile /u/m211054/host.list
#poe ~puetz/bin/hybrid_launch ${MODDIR}/${MODBIN} -procs $ncpus -hfile /u/m211054/host.list

tprofprefix=""
if [[ ${profile} == *@(tprof)* ]]; then
  trace_running=$(trcstop) || echo trcstop status $?
  tprofprefix="tprof -usz -p ${MODBIN} -x "
fi

if [[ ${profile} == *@(rusage)* ]]; then
  mkdir -p rusage
  export MODDIR
  export MODBIN
  if [[ ${profile} == *@(tprof)* ]]; then
    tprofcmd=\047poe ksh93 -c \047\042\047\042\047exec getrusage -o rusage/mpiom.${MP_CHILD} ${MODDIR}/${MODBIN}\047\042\047\042\047\047
    ${tprofprefix} ${tprofcmd} ${mpilaunch_args} -procs ${ncpus}
    mpiom_retval=$?
  else
    poe ksh93 -c \047exec getrusage -o rusage/mpiom.${MP_CHILD} ${MODDIR}/${MODBIN}\047 ${mpilaunch_args} -procs ${ncpus}
    mpiom_retval=$?
  fi
  getrusage_aggregate --aggregate-key="wall-clock time" --aggregate-key="max rss" rusage/mpiom.* > rusage/mpiom.aggregate
else
  ${tprofprefix} poe ${MODDIR}/${MODBIN} ${mpilaunch_args} -procs ${ncpus}
  mpiom_retval=$?
fi
[[ ${mpiom_retval} -eq 0 ]] || {
   echo " MPIOM did not end correctly: exit code is ${mpiom_retval}"
   exit 1
}
'
  ;;

  (none)
if test -n "${MPI}"  ; then
printf '
# model without MPI parallelization
${MODDIR}/${MODBIN}
'
else

[[ x"/opt/cray/pe/mpt/7.7.10/gni/mpich-intel/16.0" == x*openmpi* ]] && {
printf '
MPI_BIN=/opt/cray/pe/mpt/7.7.10/gni/mpich-intel/16.0/bin
${MPI_BIN}/mpiexec -x MPIOM_THREADS -x FORT_BUFFERED -n ${ncpus} ${mpilaunch_args} ${MODDIR}/${MODBIN}
'
}
[[ x"/opt/cray/pe/mpt/7.7.10/gni/mpich-intel/16.0" == x*mpich* || x"/opt/cray/pe/mpt/7.7.10/gni/mpich-intel/16.0" == x*mvapich* ]] && {
printf '
MPI_BIN=/opt/cray/pe/mpt/7.7.10/gni/mpich-intel/16.0/bin
${MPI_BIN}/mpiexec -l -envall -n ${ncpus} ${mpilaunch_args} ${MODDIR}/${MODBIN}
'
}

fi
  ;;

  (SGE)
printf '
MPIROOT=/opt/cray/pe/mpt/7.7.10/gni/mpich-intel/16.0
MPI_BIN=${MPIROOT}/bin
##${MPI_BIN}/mpiexec --prefix ${MPIROOT} -display-map -x MPIOM_THREADS -x FORT_BUFFERED -np ${ncpus} -bynode ${MODDIR}/${MODBIN}
${MPI_BIN}/mpiexec -np ${ncpus} ${MODDIR}/${MODBIN}

#for interactive use with  NAG compiler and gbd
##${MPI_BIN}/mpiexec -debugger "gdb --args @mpirun@ ${mpilaunch_args}" -debug -host tornado1,tornado1,tornado1,tornado1 -np 4 ${MODDIR}/${MODBIN}
'
  ;;

  (NQS)
printf 'mpirun -np ${ncpus} ${mpilaunch_args} ${MODDIR}/${MODBIN}'
  ;;

  (SLURM)
    case $HOSTNAME in
      (thunder*)
        printf '
MPIROOT=/opt/cray/pe/mpt/7.7.10/gni/mpich-intel/16.0
MPI_BIN=${MPIROOT}/bin
${MPI_BIN}/mpirun -np ${ncpus} ${mpilaunch_args} ${MODDIR}/${MODBIN}'
        ;;
      (btc*|mlogin*|*)
        [[ x"/opt/cray/pe/mpt/7.7.10/gni/mpich-intel/16.0" == x*impi* ]] && printf '

        export I_MPI_FABRICS=shm:dapl
        export I_MPI_FALLBACK=disable
        export I_MPI_SLURM_EXT=1

        # Set I_MPI_LARGE_SCALE_THRESHOLD to a value larger than the number of your MPI-tasks if you use 8192 or more tasks.
        export I_MPI_LARGE_SCALE_THRESHOLD=8192




        '

        [[ x"/opt/cray/pe/mpt/7.7.10/gni/mpich-intel/16.0" == x*bullx* ]] && printf '


        ulimit -s 102400 # using bash

        export OMPI_MCA_pml=cm
        export OMPI_MCA_mtl=mxm
        export MXM_RDMA_PORTS=mlx5_0:1
        export OMPI_MCA_coll=\^ghc
        export OMPI_MCA_coll_fca_priority=95
        export OMPI_MCA_coll_fca_enable=1
        '
        printf '
srun --propagate=STACK --kill-on-bad-exit=1 --cpu_bind=verbose,cores --distribution=block:block -n ${ncpus} ${mpilaunch_args} ${MODDIR}/${MODBIN}'
        ;;
    esac
  ;;

esac)

echo "Integration completed on \$(date)"
#=============================================================================
if [[ "\${profile}" != "" ]]; then
  set +e
  jobid=\$(echo \$LOADL_STEP_ID | awk -F. '{print \$(NF-1)}')
  profdir=prof_\${run_start}.\${jobid}
  mkdir \${profdir}
  mv gmon.out* \${profdir} 2>/dev/null || echo 'INFO: no gmon.out profiling data present'
  mv poe.prof \${profdir}/mpiom_tprof.out 2>/dev/null || echo 'INFO: no tprof profiling data present'
  mv rusage \${profdir} 2>/dev/null || echo 'INFO: no rusage profiling data present'
  mv mpi_profile* single_trace* \${profdir} 2>/dev/null || echo 'INFO: no MPI profiling data present'
  mv hpc_profile*.hpm hpc_profile*.viz \${profdir} 2>/dev/null || echo 'INFO: no HPM profiling data present'
  cp -p OCECTL \${profdir}
  tar cvf \${profdir}/oceout.tar oceout*
  [[ \${hamocc} == "true" ]] && tar cvf \${profdir}/bgcout.tar bgcout*
  rm -f oceout* bgcout*
fi

[[ -d  \${ARCDIR}/restart ]] || /usr/bin/mkdir -p \${ARCDIR}/restart
[[ -d  \${ARCDIR}/outdata ]] || /usr/bin/mkdir -p \${ARCDIR}/outdata

model_date=\$(<model_date.asc)
run_start=\$(echo \${model_date} | awk '{print \$1}')
run_end=\$(echo \${model_date} | awk '{print \$2}')
next_run_start=\$(echo \${model_date} | awk '{print \$3}')
timestamp_out=\${run_start}_\${run_end}
timestamp_res=\${run_end}

# restart files
for i in rerun_\${EXPNO}_* ; do
    if [ -r \$i ]; then
        # insert timestamp between basename and extension
        n=\`echo \$i | sed "s,^\(.*\)\.\(.*\)\$,\1_\${timestamp_out}.\2,"\`
        cp \$i \${ARCDIR}/restart/\${n}
    fi
done

# outdata files
for i in \${EXPNO}_mpiom_* \${EXPNO}_hamocc_* ; do
    if [ -r \$i ]; then
        # insert timestamp between basename and extension
        n=\`echo \$i | sed "s,^\(.*\)\.\(.*\)\$,\1_\${timestamp_out}.\2,"\`
        mv \$i \${ARCDIR}/outdata/\${n}
    fi
done

if [[ \${hamocc} == "true" ]] && [[ "\${profile}" == "" ]]; then
  cp bgcout  \${ARCDIR}/outdata/bgcout_\${timestamp_out}
  cp oceout  \${ARCDIR}/outdata/oceout_\${timestamp_out}
fi
#=============================================================================

#=============================================================================

done

#=============================================================================
if [[ \${SINFO} == "yes" ]]; then
#write experiment short info sheet to SINFO_DIR
cat > \$EXPNO.info<<EOF
user: \${LOGNAME}
experiment_number : \${EXPNO}
working_directory : \${EXPDIR}
archive_directory : \${ARCDIR}
executable : \${MODDIR}/\${MODBIN}
grid : \${GRID}
level : \${LEV}
enable_hamocc : \${hamocc}
intial_data : \${INITIAL_DATA}
forcing_data : ${forcing}
experiment_start : \${model_start}
experiment_end : \${model_end}
restart : \${restart}
experiment_short_info : \${SHORT_INFO}
EOF

if [[ ! -f \${SINFO_DIR} ]]; then
  set +e
  mkdir -p \${SINFO_DIR}
  set -e
fi

if [[ ! -f \${SINFO_DIR}/\${EXPNO}.info && -d \${SINFO_DIR} && -w \${SINFO_DIR} ]]; then
  \cp \$EXPNO.info \${SINFO_DIR}/\${EXPNO}.info
fi
fi
#=============================================================================

nsdate=\$(echo \${next_run_start} | tr -d '-')
fdate=\$(echo \${model_end}   | tr -d '-')
if [ \${nsdate} -lt \${fdate} ] ; then
  echo "submitting next job"
  ${submit} ${jobfile}
fi

exit
EOF1

# Do _not_ recommend suicide of calling shell
start="$submit $jobfile"
[[ -z "$submit" || "$submit" == exec ]] && start="$jobfile"

chmod 755 ${jobfile}
printf "\n%s\n" "To start MPIOM experiment ${EXPNO}:"
printf "%s\n" "   cd ${EXPDIR}"
printf "%s\n\n" "   ${start}"
#-----------------------------------------------------------------------------

exit 0
